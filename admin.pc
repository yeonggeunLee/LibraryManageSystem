// win32 Visual C 컴파일시 추가
// 프로그램 가장 첫 줄에 추가할 것
#define _CRT_SECURE_NO_WARNINGS

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <conio.h>

/* for oracle */
#include <sqlda.h>
#include <sqlca.h>
#include <sqlcpr.h>

//#ifdef WIN32
#include <windows.h>
/*---------------  화면 커서 위치 제어 ----------------------*/
void gotoxy(int x, int y) ;
void getxy(int *x, int *y) ;
void clrscr(void) ;
/*-----------------------------------------------------------*/
#define getch() _getch()

void DB_connect();
void add_book();
void search_book();
void delete_book();
void update_book();
void update_status();
void add_user();
void search_user();
void delete_user();
void update_user();

void sql_error(char *msg) ;

// win32 Visual C 컴파일시 추가
#define getch() _getch()

void main()
{
	DB_connect();

	getch();
}
void DB_connect()
{
EXEC SQL BEGIN DECLARE SECTION;
   VARCHAR uid[80];
   VARCHAR pwd[20];
EXEC SQL END DECLARE SECTION;

   /* 본인 계정이름으로 바꾸어 쓸 것 */
   strcpy((char *)uid.arr,"b20212954@//sedb.deu.ac.kr:1521/orcl");
   uid.len = (short) strlen((char *)uid.arr);
   /* 본인 계정 암호로 바꾸어 쓸 것 */
   strcpy((char *)pwd.arr,"20212954");
   pwd.len = (short) strlen((char *)pwd.arr);

   EXEC SQL CONNECT :uid IDENTIFIED BY :pwd;

	// connection이 실패했을경우의 처리부분

	if (sqlca.sqlcode != 0 && sqlca.sqlcode != -1405){ 
		printf("\7Connect error: %s", sqlca.sqlerrm.sqlerrmc);
		getch();
		exit(-1);
	}

    printf("Oracle Connect SUCCESS by %s\n", uid.arr);
}

void add_book()
{
EXEC SQL BEGIN DECLARE SECTION;
   char dynstmt[1000];
EXEC SQL END DECLARE SECTION;

    char num[5];
    char title[17];
    char author[16];
    char publisher[16];

   /* Register sql_error() as the error handler. */
   EXEC SQL WHENEVER SQLERROR DO sql_error("\7ORACLE ERROR:\n");
   clrscr();

   /* 도서 번호 입력 */
    gotoxy(20,7)  ; 
    gets(num);
    
   /* 책 이름 입력 */
    gotoxy(20,9)  ;
    gets(title);

   /* 저자 입력 */
    gotoxy(20,11) ;
    gets(author);

   /* 출판사 입력 */
    gotoxy(20,13) ;
    gets(publisher);

    sprintf(dynstmt,"INSERT INTO BOOKS VALUES ( %s, '%s', '%s', '%s')" ,num, title, author, publisher);

    printf("stmt:%s\n", dynstmt);
   /* 실행시킬 SQL 문장*/
    EXEC SQL EXECUTE IMMEDIATE :dynstmt ;

    EXEC SQL COMMIT WORK ;
}

void search_book()
{
EXEC SQL BEGIN DECLARE SECTION;
   char dynstmt[1000];
EXEC SQL END DECLARE SECTION;

    char title[17];
    char author[16];

   /* Register sql_error() as the error handler. */
   EXEC SQL WHENEVER SQLERROR DO sql_error("\7ORACLE ERROR:\n");
   clrscr();
    
   /* 책 이름 입력 */
    gotoxy(20,7)  ;
    gets(title);

   /* 저자 입력 */
    gotoxy(20,9) ;
    gets(author);

    sprintf(dynstmt,"SELECT BOOK_NUMBER, BOOK_TITLE, BOOK_AUTHOR, BOOK_PUBLISHER FROM BOOKS where BOOK_TITLE LIKE '%%%s%%' and BOOK_AUTHOR LIKE '%%%s%%'  ",
                    title, author); 

    printf("stmt:%s\n", dynstmt);
   /* 실행시킬 SQL 문장*/
    EXEC SQL EXECUTE IMMEDIATE :dynstmt ;

    EXEC SQL WHENEVER NOT FOUND STOP;

    EXEC SQL COMMIT WORK ;
}

void update_book()
{
EXEC SQL BEGIN DECLARE SECTION;
   char dynstmt[1000];
EXEC SQL END DECLARE SECTION;

    char num[5];
    char title[17];
    char author[16];
    char publisher[16];

   /* Register sql_error() as the error handler. */
   EXEC SQL WHENEVER SQLERROR DO sql_error("\7ORACLE ERROR:\n");
   clrscr();

   /* 도서 번호 입력 */
    gotoxy(20,7)  ; 
    gets(num);
    
   /* 책 이름 입력 */
    gotoxy(20,9)  ;
    gets(title);

   /* 저자 입력 */
    gotoxy(20,11) ;
    gets(author);

   /* 출판사 입력 */
    gotoxy(20,13) ;
    gets(publisher);

    sprintf(dynstmt,"UPDATE BOOKS SET BOOK_NUMBER = %s, BOOK_TITLE= %s,BOOK_AUTHOR = %s, BOOK_PUBLISHER = '%s where BOOK_NUMBER = %s ", num, title, author, publisher, num);

    printf("stmt:%s\n", dynstmt);
   /* 실행시킬 SQL 문장*/
    EXEC SQL EXECUTE IMMEDIATE :dynstmt ;

    EXEC SQL WHENEVER NOT FOUND STOP;

    EXEC SQL COMMIT WORK ;
}

void delete_book()
{
EXEC SQL BEGIN DECLARE SECTION;
   char dynstmt[1000];
EXEC SQL END DECLARE SECTION;

    char num[5];
    char title[17];
    char author[16];
    char publisher[16];
    char flag;

   /* Register sql_error() as the error handler. */
   EXEC SQL WHENEVER SQLERROR DO sql_error("\7ORACLE ERROR:\n");
   clrscr();

   printf("삭제할 책 이름을 입력하세요 : !!\n") ;   
   gets(title) ;

   printf("삭제할 도서 번호을 입력하세요 : !!\n") ;   
   gets(num) ;

   printf("해당 책을 삭제하시겠습니까? (y/n) :");   

   flag = (char *)getch() ;

   if( flag == 'y' || flag =='Y' ){
       sprintf(dynstmt,"DELETE FROM BOOKS WHERE BOOK_TITLE = %s AND BOOK_NUMBER = %s ", title, num);
       printf("stmt:%s\n", dynstmt);
       EXEC SQL EXECUTE IMMEDIATE :dynstmt ;

       EXEC SQL WHENEVER NOT FOUND STOP;

       EXEC SQL COMMIT WORK ; 
   }
   else {
       printf("삭제를 취소합니다.\n");
   }
}

void update_status()
{
EXEC SQL BEGIN DECLARE SECTION;
   char dynstmt[1000];
EXEC SQL END DECLARE SECTION;

    char book_num[5];
    char user_num[5];
    char loan_date[5];
    char due_date[5];
    char is_available[5];

   /* Register sql_error() as the error handler. */
   EXEC SQL WHENEVER SQLERROR DO sql_error("\7ORACLE ERROR:\n");
   clrscr();

   /* 도서 번호 입력 */
    gotoxy(20,7); 
    gets(book_num);
    
   /* 회원 번호 입력 */
    gotoxy(20,9);
    gets(user_num);

   /* 대여 날짜 입력 */
    gotoxy(20,11) ;
    gets(loan_date);

   /* 반납 마감 일자 입력 */
    gotoxy(20,13);
    gets(due_date);

   /* 반납 여부 입력 */
    gotoxy(20,15);
    gets(is_available);

    sprintf(dynstmt,"UPDATE STATUS SET BOOK_DEUDATE= %s, BOOK_ISAVAILABLE = %s where BOOK_NUMBER = %s and USER_NUMBER = %s and BOOK_LOANDATE = %s", due_date, is_available, book_num, user_num, loan_date);

    printf("stmt:%s\n", dynstmt);
   /* 실행시킬 SQL 문장*/
    EXEC SQL EXECUTE IMMEDIATE :dynstmt ;

    EXEC SQL WHENEVER NOT FOUND STOP;

    EXEC SQL COMMIT WORK ;
}

void add_user()
{
EXEC SQL BEGIN DECLARE SECTION;
   char dynstmt[1000];
EXEC SQL END DECLARE SECTION;

    char num[5];
    char name[17];
    int loan;
    int overdue;

   /* Register sql_error() as the error handler. */
   EXEC SQL WHENEVER SQLERROR DO sql_error("\7ORACLE ERROR:\n");
   clrscr();

   /* 회원 이름 입력 */
    gotoxy(20,7)  ; 
    gets(name);
    
   /* 회원 번호 입력 */
    gotoxy(20,9)  ;
    gets(num);

    loan = 0;
    overdue = 0;


    sprintf(dynstmt,"INSERT INTO USERS VALUES ( %s, '%s', '%d', '%d')" ,num, name, loan, overdue);

    printf("stmt:%s\n", dynstmt);
   /* 실행시킬 SQL 문장*/
    EXEC SQL EXECUTE IMMEDIATE :dynstmt ;

    EXEC SQL COMMIT WORK ;
}

void search_user()
{
EXEC SQL BEGIN DECLARE SECTION;
   char dynstmt[1000];
EXEC SQL END DECLARE SECTION;

    char num[5];
    char name[17];


   /* Register sql_error() as the error handler. */
   EXEC SQL WHENEVER SQLERROR DO sql_error("\7ORACLE ERROR:\n");
   clrscr();
    
   /* 회원 이름 입력 */
    gotoxy(20,7)  ;
    gets(name);

   /* 회원 번호 입력 */
    gotoxy(20,9) ;
    gets(num);

    sprintf(dynstmt,"SELECT USER_NAME, USER_NUMBER, USER_LOANS, USER_OVERDUE FROM USERS WHERE USER_NAME LIKE '%%%s%%' AND USER_NUMBER LIKE '%%%s%%'",
                    name, num); 

    printf("stmt:%s\n", dynstmt);
   /* 실행시킬 SQL 문장*/
    EXEC SQL EXECUTE IMMEDIATE :dynstmt ;

    EXEC SQL WHENEVER NOT FOUND STOP;

    EXEC SQL COMMIT WORK ;
}

void update_user()
{
EXEC SQL BEGIN DECLARE SECTION;
   char dynstmt[1000];
EXEC SQL END DECLARE SECTION;

    char num[5];
    char name[17];
    char new_num[5];
    char new_name[17];
    int loan = 0;
    int overdue = 0;

   /* Register sql_error() as the error handler. */
   EXEC SQL WHENEVER SQLERROR DO sql_error("\7ORACLE ERROR:\n");
   clrscr();

   /* 기존 회원 이름 입력 */
    gotoxy(20,7)  ; 
    gets(name);
    
   /* 기존 회원 번호 입력 */
    gotoxy(20,9)  ;
    gets(num);

   /* 새로운 회원 이름 입력 */
    gotoxy(20,11)  ; 
    gets(name);
    
   /* 새로운 회원 번호 입력 */
    gotoxy(20,13)  ;
    gets(num);

   /* 대출 권수 입력 */
    gotoxy(20,15) ;
    gets(loan);

   /* 연체 일수 입력 */
    gotoxy(20,17) ;
    gets(overdue);

    sprintf(dynstmt,"UPDATE USERS SET USER_NAME = %s, USER_NUMBER = %s,USER_LOANS = %d, USER_OVERDUE = '%d WHERE USER_NAME= %s  AND USER_NUMBER= %s", new_name, new_num, loan, overdue, name, num);

    printf("stmt:%s\n", dynstmt);
   /* 실행시킬 SQL 문장*/
    EXEC SQL EXECUTE IMMEDIATE :dynstmt ;

    EXEC SQL WHENEVER NOT FOUND STOP;

    EXEC SQL COMMIT WORK ;
}

void delete_user()
{
EXEC SQL BEGIN DECLARE SECTION;
   char dynstmt[1000];
EXEC SQL END DECLARE SECTION;

    char num[5];
    char name[17];
    char flag;

   /* Register sql_error() as the error handler. */
   EXEC SQL WHENEVER SQLERROR DO sql_error("\7ORACLE ERROR:\n");
   clrscr();

   printf("삭제할 회원 이름을 입력하세요 : !!\n") ;   
   gets(name) ;

   printf("삭제할 회원 번호를 입력하세요 : !!\n") ;   
   gets(num) ;

   printf("해당 회원을 삭제하시겠습니까? (y/n) :");   

   flag = (char *)getch() ;

   if( flag == 'y' || flag =='Y' ){
       sprintf(dynstmt,"DELETE FROM USERS WHERE USER_NAME= %s  AND USER_NUMBER= %s", name, num);
       printf("stmt:%s\n", dynstmt);
       EXEC SQL EXECUTE IMMEDIATE :dynstmt ;

       EXEC SQL WHENEVER NOT FOUND STOP;

       EXEC SQL COMMIT WORK ; 
   }
   else {
       printf("삭제를 취소합니다.\n");
   }
}


/* --------------------------------------------------------------------------
void sql_error(msg)

   errrpt prints the ORACLE error msg and number.
-------------------------------------------------------------------------- */
void sql_error(char *msg)

{
    char err_msg[128];
    size_t buf_len, msg_len;

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    printf("\n%s\n", msg);
    buf_len = sizeof (err_msg);
    sqlglm(err_msg, &buf_len, &msg_len);
    printf("%.*s\n", msg_len, err_msg);
    getch();
    
    EXEC SQL ROLLBACK WORK;

}

/*---------------  화면 커서 제어 함수 --------------------*/
#define STD_HANDLE GetStdHandle(STD_OUTPUT_HANDLE)

void gotoxy(int x, int y)
{
    COORD Cur= {(SHORT)x, (SHORT) y};

    SetConsoleCursorPosition(STD_HANDLE, Cur);
}

void getxy(int *x, int *y)
{
    CONSOLE_SCREEN_BUFFER_INFO Buf ;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &Buf);
    *x = (int)Buf.dwCursorPosition.X ;
    *y = (int)Buf.dwCursorPosition.Y ;
 
}

void clrscr(void)
{
    COORD Cur= {0, 0};
    unsigned long dwLen;

    FillConsoleOutputCharacter(STD_HANDLE, ' ', 80*25, Cur, &dwLen);
}